function [Px, Py, Vx, Vy, Ax, Ay] = optimalcontrol(x, Ux_1_init, Uy_1_init, v_des, h)

n_agents = length(x)/4;

u_1_init = [Ux_1_init, Uy_1_init];

T = size(u_1_init, 1);
sample = struct('s', x, 'u', [u_1_init, zeros(T, 2*(n_agents - 1))]);

mdp_data = struct(...
	'time_step', h, ... [s]
	'n_ped', n_agents, ...
	'dims', 4*n_agents, ... positions, velocities
	'udims', 2*n_agents, ... accelerations
	'v_des', v_des, ...
	'wheelchair_companion_pair', logical(zeros(n_agents)), ...
	'wheelchair_pedestrian_pair', logical(zeros(n_agents)), ...
	'other_pair', logical(ones(n_agents)), ...
	'type', zeros(1, n_agents) ...
);

features = {... 
	struct('expec', 1, 'type', 'acc2sum', 'type_c', false, 'type_w', false, 'type_other', false, 'w0', -1) ...
	struct('expec', 1, 'type', 'verr2sum', 'type_c', false, 'type_w', false, 'type_other', false) ...
	struct('expec', 1, 'type', 'dgaussiansum', 'sigma', 0.5, 'skip_wp', false, 'skip_wc', false, 'skip_other', false) ...
	struct('expec', 1, 'type', 'iesum', 'eps2', 0.01, 'a', 25, 'R', 0.4, 'skip_wp', false, 'skip_wc', false, 'skip_other', false) ...
};
theta = [...
	-0.1 ...
	-1 ...
	-0.25 ...
	-1.0 ...
];
reward = struct('type', 'sum', 'theta', theta, 'features', {features});

test_params = struct(...
	...'fast_features', true, ...
	'training_sample_lengths', T, ...
	'test_samples', 0, ... 
	'training_samples', 1, ... 
	'test_restarts', 1, ... 
	'example_restarts', 1, ... 
	'test_optimal', false, ... 
	'example_optimal', false, ... 
	'example_recompute_optimal', false ... 
);

%tic
%[re_samples, ~] = resampleexamples(mdp_data, 'crowdworld', ...
%			reward, reward, test_params, {sample}, {}, true);
%toc

% Set up optimization options.
options = struct();
options.Method = 'lbfgs';
options.maxIter = 1000;
options.MaxFunEvals = 1000;
options.display = 'on';
options.TolX = 1.0e-16;
options.TolFun = 1.0e-8;
options.Display = 'off';

for f = 1:length(reward.features)
	reward.features{f}.fast = true;
end

% Run minFunc.
[u_, r] = minFunc(@(p)fastreward(p, x, mdp_data, 'crowdworld', ...
	reward), sample.u(:), options);
u = reshape(u_, size(sample.u, 1), mdp_data.udims);
states = feval('crowdworldcontrol', mdp_data, sample.s, u);

%disp(max(max(abs(re_samples{1}.u - u))))
%disp(max(max(abs(re_samples{1}.states - states))))

Px = [x(1); states(:, 1)];
Py = [x(2); states(:, 2)];
Vx = [x(1 + 2*n_agents); states(:, 1 + 2*n_agents)];
Vy = [x(2 + 2*n_agents); states(:, 2 + 2*n_agents)];
Ax = u(:, 1);
Ay = u(:, 2);
